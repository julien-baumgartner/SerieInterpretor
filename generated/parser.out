Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    RETURN

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement ;
Rule 2     programme -> statement ; programme
Rule 3     statement -> assignation-valeur
Rule 4     statement -> assignation-serie
Rule 5     statement -> structure
Rule 6     statement -> PRINT expression
Rule 7     assignation-valeur -> IDENTIFIER = expression
Rule 8     assignation-serie -> IDENTIFIER = def-iter : expression
Rule 9     assignation-serie -> IDENTIFIER = FOREACH ( def-iter ) { programme }
Rule 10    def-iter -> IDENTIFIER ITER IDENTIFIER
Rule 11    def-iter -> IDENTIFIER ITER IDENTIFIER AS expression
Rule 12    structure -> WHILE expression { programme }
Rule 13    structure -> IF expression { programme }
Rule 14    structure -> IF expression { programme } ELSE { programme }
Rule 15    expression -> expression ADD_OP expression
Rule 16    expression -> expression MUL_OP expression
Rule 17    expression -> ADD_OP expression
Rule 18    expression -> ( expression )
Rule 19    expression -> NUMBER
Rule 20    expression -> IDENTIFIER
Rule 21    expression -> IDENTIFIER [ expression ]

Terminals, with rules where they appear

(                    : 9 18
)                    : 9 18
:                    : 8
;                    : 1 2
=                    : 7 8 9
ADD_OP               : 15 17
AS                   : 11
ELSE                 : 14
FOREACH              : 9
IDENTIFIER           : 7 8 9 10 10 11 11 20 21
IF                   : 13 14
ITER                 : 10 11
MUL_OP               : 16
NUMBER               : 19
PRINT                : 6
RETURN               : 
WHILE                : 12
[                    : 21
]                    : 21
error                : 
{                    : 9 12 13 14 14
}                    : 9 12 13 14 14

Nonterminals, with rules where they appear

assignation-serie    : 4
assignation-valeur   : 3
def-iter             : 8 9
expression           : 6 7 8 11 12 13 14 15 15 16 16 17 18 21
programme            : 2 9 12 13 14 14 0
statement            : 1 2
structure            : 5

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement ;
    (2) programme -> . statement ; programme
    (3) statement -> . assignation-valeur
    (4) statement -> . assignation-serie
    (5) statement -> . structure
    (6) statement -> . PRINT expression
    (7) assignation-valeur -> . IDENTIFIER = expression
    (8) assignation-serie -> . IDENTIFIER = def-iter : expression
    (9) assignation-serie -> . IDENTIFIER = FOREACH ( def-iter ) { programme }
    (12) structure -> . WHILE expression { programme }
    (13) structure -> . IF expression { programme }
    (14) structure -> . IF expression { programme } ELSE { programme }

    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 8
    WHILE           shift and go to state 1
    IF              shift and go to state 7

    structure                      shift and go to state 2
    assignation-valeur             shift and go to state 3
    programme                      shift and go to state 4
    assignation-serie              shift and go to state 5
    statement                      shift and go to state 9

state 1

    (12) structure -> WHILE . expression { programme }
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 10
    (               shift and go to state 11
    NUMBER          shift and go to state 12
    IDENTIFIER      shift and go to state 14

    expression                     shift and go to state 13

state 2

    (5) statement -> structure .

    ;               reduce using rule 5 (statement -> structure .)


state 3

    (3) statement -> assignation-valeur .

    ;               reduce using rule 3 (statement -> assignation-valeur .)


state 4

    (0) S' -> programme .



state 5

    (4) statement -> assignation-serie .

    ;               reduce using rule 4 (statement -> assignation-serie .)


state 6

    (6) statement -> PRINT . expression
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 10
    (               shift and go to state 11
    NUMBER          shift and go to state 12
    IDENTIFIER      shift and go to state 14

    expression                     shift and go to state 15

state 7

    (13) structure -> IF . expression { programme }
    (14) structure -> IF . expression { programme } ELSE { programme }
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 10
    (               shift and go to state 11
    NUMBER          shift and go to state 12
    IDENTIFIER      shift and go to state 14

    expression                     shift and go to state 16

state 8

    (7) assignation-valeur -> IDENTIFIER . = expression
    (8) assignation-serie -> IDENTIFIER . = def-iter : expression
    (9) assignation-serie -> IDENTIFIER . = FOREACH ( def-iter ) { programme }

    =               shift and go to state 17


state 9

    (1) programme -> statement . ;
    (2) programme -> statement . ; programme

    ;               shift and go to state 18


state 10

    (17) expression -> ADD_OP . expression
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 10
    (               shift and go to state 11
    NUMBER          shift and go to state 12
    IDENTIFIER      shift and go to state 14

    expression                     shift and go to state 19

state 11

    (18) expression -> ( . expression )
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 10
    (               shift and go to state 11
    NUMBER          shift and go to state 12
    IDENTIFIER      shift and go to state 14

    expression                     shift and go to state 20

state 12

    (19) expression -> NUMBER .

    ]               reduce using rule 19 (expression -> NUMBER .)
    ADD_OP          reduce using rule 19 (expression -> NUMBER .)
    MUL_OP          reduce using rule 19 (expression -> NUMBER .)
    ;               reduce using rule 19 (expression -> NUMBER .)
    {               reduce using rule 19 (expression -> NUMBER .)
    )               reduce using rule 19 (expression -> NUMBER .)
    :               reduce using rule 19 (expression -> NUMBER .)


state 13

    (12) structure -> WHILE expression . { programme }
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    {               shift and go to state 23
    ADD_OP          shift and go to state 22
    MUL_OP          shift and go to state 21


state 14

    (20) expression -> IDENTIFIER .
    (21) expression -> IDENTIFIER . [ expression ]

    ]               reduce using rule 20 (expression -> IDENTIFIER .)
    ADD_OP          reduce using rule 20 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 20 (expression -> IDENTIFIER .)
    ;               reduce using rule 20 (expression -> IDENTIFIER .)
    {               reduce using rule 20 (expression -> IDENTIFIER .)
    )               reduce using rule 20 (expression -> IDENTIFIER .)
    :               reduce using rule 20 (expression -> IDENTIFIER .)
    [               shift and go to state 24


state 15

    (6) statement -> PRINT expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ;               reduce using rule 6 (statement -> PRINT expression .)
    ADD_OP          shift and go to state 22
    MUL_OP          shift and go to state 21


state 16

    (13) structure -> IF expression . { programme }
    (14) structure -> IF expression . { programme } ELSE { programme }
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    {               shift and go to state 25
    ADD_OP          shift and go to state 22
    MUL_OP          shift and go to state 21


state 17

    (7) assignation-valeur -> IDENTIFIER = . expression
    (8) assignation-serie -> IDENTIFIER = . def-iter : expression
    (9) assignation-serie -> IDENTIFIER = . FOREACH ( def-iter ) { programme }
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]
    (10) def-iter -> . IDENTIFIER ITER IDENTIFIER
    (11) def-iter -> . IDENTIFIER ITER IDENTIFIER AS expression

    FOREACH         shift and go to state 28
    ADD_OP          shift and go to state 10
    (               shift and go to state 11
    NUMBER          shift and go to state 12
    IDENTIFIER      shift and go to state 27

    def-iter                       shift and go to state 26
    expression                     shift and go to state 29

state 18

    (1) programme -> statement ; .
    (2) programme -> statement ; . programme
    (1) programme -> . statement ;
    (2) programme -> . statement ; programme
    (3) statement -> . assignation-valeur
    (4) statement -> . assignation-serie
    (5) statement -> . structure
    (6) statement -> . PRINT expression
    (7) assignation-valeur -> . IDENTIFIER = expression
    (8) assignation-serie -> . IDENTIFIER = def-iter : expression
    (9) assignation-serie -> . IDENTIFIER = FOREACH ( def-iter ) { programme }
    (12) structure -> . WHILE expression { programme }
    (13) structure -> . IF expression { programme }
    (14) structure -> . IF expression { programme } ELSE { programme }

    $end            reduce using rule 1 (programme -> statement ; .)
    }               reduce using rule 1 (programme -> statement ; .)
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 8
    WHILE           shift and go to state 1
    IF              shift and go to state 7

    structure                      shift and go to state 2
    assignation-valeur             shift and go to state 3
    programme                      shift and go to state 30
    assignation-serie              shift and go to state 5
    statement                      shift and go to state 9

state 19

    (17) expression -> ADD_OP expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ]               reduce using rule 17 (expression -> ADD_OP expression .)
    ADD_OP          reduce using rule 17 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 17 (expression -> ADD_OP expression .)
    ;               reduce using rule 17 (expression -> ADD_OP expression .)
    {               reduce using rule 17 (expression -> ADD_OP expression .)
    )               reduce using rule 17 (expression -> ADD_OP expression .)
    :               reduce using rule 17 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 22 ]
  ! MUL_OP          [ shift and go to state 21 ]


state 20

    (18) expression -> ( expression . )
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    )               shift and go to state 31
    ADD_OP          shift and go to state 22
    MUL_OP          shift and go to state 21


state 21

    (16) expression -> expression MUL_OP . expression
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 10
    (               shift and go to state 11
    NUMBER          shift and go to state 12
    IDENTIFIER      shift and go to state 14

    expression                     shift and go to state 32

state 22

    (15) expression -> expression ADD_OP . expression
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 10
    (               shift and go to state 11
    NUMBER          shift and go to state 12
    IDENTIFIER      shift and go to state 14

    expression                     shift and go to state 33

state 23

    (12) structure -> WHILE expression { . programme }
    (1) programme -> . statement ;
    (2) programme -> . statement ; programme
    (3) statement -> . assignation-valeur
    (4) statement -> . assignation-serie
    (5) statement -> . structure
    (6) statement -> . PRINT expression
    (7) assignation-valeur -> . IDENTIFIER = expression
    (8) assignation-serie -> . IDENTIFIER = def-iter : expression
    (9) assignation-serie -> . IDENTIFIER = FOREACH ( def-iter ) { programme }
    (12) structure -> . WHILE expression { programme }
    (13) structure -> . IF expression { programme }
    (14) structure -> . IF expression { programme } ELSE { programme }

    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 8
    WHILE           shift and go to state 1
    IF              shift and go to state 7

    structure                      shift and go to state 2
    assignation-valeur             shift and go to state 3
    programme                      shift and go to state 34
    assignation-serie              shift and go to state 5
    statement                      shift and go to state 9

state 24

    (21) expression -> IDENTIFIER [ . expression ]
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 10
    (               shift and go to state 11
    NUMBER          shift and go to state 12
    IDENTIFIER      shift and go to state 14

    expression                     shift and go to state 35

state 25

    (13) structure -> IF expression { . programme }
    (14) structure -> IF expression { . programme } ELSE { programme }
    (1) programme -> . statement ;
    (2) programme -> . statement ; programme
    (3) statement -> . assignation-valeur
    (4) statement -> . assignation-serie
    (5) statement -> . structure
    (6) statement -> . PRINT expression
    (7) assignation-valeur -> . IDENTIFIER = expression
    (8) assignation-serie -> . IDENTIFIER = def-iter : expression
    (9) assignation-serie -> . IDENTIFIER = FOREACH ( def-iter ) { programme }
    (12) structure -> . WHILE expression { programme }
    (13) structure -> . IF expression { programme }
    (14) structure -> . IF expression { programme } ELSE { programme }

    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 8
    WHILE           shift and go to state 1
    IF              shift and go to state 7

    structure                      shift and go to state 2
    assignation-valeur             shift and go to state 3
    programme                      shift and go to state 36
    assignation-serie              shift and go to state 5
    statement                      shift and go to state 9

state 26

    (8) assignation-serie -> IDENTIFIER = def-iter . : expression

    :               shift and go to state 37


state 27

    (20) expression -> IDENTIFIER .
    (21) expression -> IDENTIFIER . [ expression ]
    (10) def-iter -> IDENTIFIER . ITER IDENTIFIER
    (11) def-iter -> IDENTIFIER . ITER IDENTIFIER AS expression

    ADD_OP          reduce using rule 20 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 20 (expression -> IDENTIFIER .)
    ;               reduce using rule 20 (expression -> IDENTIFIER .)
    [               shift and go to state 24
    ITER            shift and go to state 38


state 28

    (9) assignation-serie -> IDENTIFIER = FOREACH . ( def-iter ) { programme }

    (               shift and go to state 39


state 29

    (7) assignation-valeur -> IDENTIFIER = expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ;               reduce using rule 7 (assignation-valeur -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 22
    MUL_OP          shift and go to state 21


state 30

    (2) programme -> statement ; programme .

    $end            reduce using rule 2 (programme -> statement ; programme .)
    }               reduce using rule 2 (programme -> statement ; programme .)


state 31

    (18) expression -> ( expression ) .

    ]               reduce using rule 18 (expression -> ( expression ) .)
    ADD_OP          reduce using rule 18 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 18 (expression -> ( expression ) .)
    ;               reduce using rule 18 (expression -> ( expression ) .)
    {               reduce using rule 18 (expression -> ( expression ) .)
    )               reduce using rule 18 (expression -> ( expression ) .)
    :               reduce using rule 18 (expression -> ( expression ) .)


state 32

    (16) expression -> expression MUL_OP expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ]               reduce using rule 16 (expression -> expression MUL_OP expression .)
    ADD_OP          reduce using rule 16 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 16 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 16 (expression -> expression MUL_OP expression .)
    {               reduce using rule 16 (expression -> expression MUL_OP expression .)
    )               reduce using rule 16 (expression -> expression MUL_OP expression .)
    :               reduce using rule 16 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 22 ]
  ! MUL_OP          [ shift and go to state 21 ]


state 33

    (15) expression -> expression ADD_OP expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ]               reduce using rule 15 (expression -> expression ADD_OP expression .)
    ADD_OP          reduce using rule 15 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 15 (expression -> expression ADD_OP expression .)
    {               reduce using rule 15 (expression -> expression ADD_OP expression .)
    )               reduce using rule 15 (expression -> expression ADD_OP expression .)
    :               reduce using rule 15 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 21

  ! MUL_OP          [ reduce using rule 15 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 22 ]


state 34

    (12) structure -> WHILE expression { programme . }

    }               shift and go to state 40


state 35

    (21) expression -> IDENTIFIER [ expression . ]
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ]               shift and go to state 41
    ADD_OP          shift and go to state 22
    MUL_OP          shift and go to state 21


state 36

    (13) structure -> IF expression { programme . }
    (14) structure -> IF expression { programme . } ELSE { programme }

    }               shift and go to state 42


state 37

    (8) assignation-serie -> IDENTIFIER = def-iter : . expression
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 10
    (               shift and go to state 11
    NUMBER          shift and go to state 12
    IDENTIFIER      shift and go to state 14

    expression                     shift and go to state 43

state 38

    (10) def-iter -> IDENTIFIER ITER . IDENTIFIER
    (11) def-iter -> IDENTIFIER ITER . IDENTIFIER AS expression

    IDENTIFIER      shift and go to state 44


state 39

    (9) assignation-serie -> IDENTIFIER = FOREACH ( . def-iter ) { programme }
    (10) def-iter -> . IDENTIFIER ITER IDENTIFIER
    (11) def-iter -> . IDENTIFIER ITER IDENTIFIER AS expression

    IDENTIFIER      shift and go to state 46

    def-iter                       shift and go to state 45

state 40

    (12) structure -> WHILE expression { programme } .

    ;               reduce using rule 12 (structure -> WHILE expression { programme } .)


state 41

    (21) expression -> IDENTIFIER [ expression ] .

    ]               reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)
    ADD_OP          reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)
    MUL_OP          reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)
    ;               reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)
    {               reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)
    )               reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)
    :               reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)


state 42

    (13) structure -> IF expression { programme } .
    (14) structure -> IF expression { programme } . ELSE { programme }

    ;               reduce using rule 13 (structure -> IF expression { programme } .)
    ELSE            shift and go to state 47


state 43

    (8) assignation-serie -> IDENTIFIER = def-iter : expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ;               reduce using rule 8 (assignation-serie -> IDENTIFIER = def-iter : expression .)
    ADD_OP          shift and go to state 22
    MUL_OP          shift and go to state 21


state 44

    (10) def-iter -> IDENTIFIER ITER IDENTIFIER .
    (11) def-iter -> IDENTIFIER ITER IDENTIFIER . AS expression

    :               reduce using rule 10 (def-iter -> IDENTIFIER ITER IDENTIFIER .)
    )               reduce using rule 10 (def-iter -> IDENTIFIER ITER IDENTIFIER .)
    AS              shift and go to state 48


state 45

    (9) assignation-serie -> IDENTIFIER = FOREACH ( def-iter . ) { programme }

    )               shift and go to state 49


state 46

    (10) def-iter -> IDENTIFIER . ITER IDENTIFIER
    (11) def-iter -> IDENTIFIER . ITER IDENTIFIER AS expression

    ITER            shift and go to state 38


state 47

    (14) structure -> IF expression { programme } ELSE . { programme }

    {               shift and go to state 50


state 48

    (11) def-iter -> IDENTIFIER ITER IDENTIFIER AS . expression
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 10
    (               shift and go to state 11
    NUMBER          shift and go to state 12
    IDENTIFIER      shift and go to state 14

    expression                     shift and go to state 51

state 49

    (9) assignation-serie -> IDENTIFIER = FOREACH ( def-iter ) . { programme }

    {               shift and go to state 52


state 50

    (14) structure -> IF expression { programme } ELSE { . programme }
    (1) programme -> . statement ;
    (2) programme -> . statement ; programme
    (3) statement -> . assignation-valeur
    (4) statement -> . assignation-serie
    (5) statement -> . structure
    (6) statement -> . PRINT expression
    (7) assignation-valeur -> . IDENTIFIER = expression
    (8) assignation-serie -> . IDENTIFIER = def-iter : expression
    (9) assignation-serie -> . IDENTIFIER = FOREACH ( def-iter ) { programme }
    (12) structure -> . WHILE expression { programme }
    (13) structure -> . IF expression { programme }
    (14) structure -> . IF expression { programme } ELSE { programme }

    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 8
    WHILE           shift and go to state 1
    IF              shift and go to state 7

    structure                      shift and go to state 2
    assignation-valeur             shift and go to state 3
    programme                      shift and go to state 53
    assignation-serie              shift and go to state 5
    statement                      shift and go to state 9

state 51

    (11) def-iter -> IDENTIFIER ITER IDENTIFIER AS expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    :               reduce using rule 11 (def-iter -> IDENTIFIER ITER IDENTIFIER AS expression .)
    )               reduce using rule 11 (def-iter -> IDENTIFIER ITER IDENTIFIER AS expression .)
    ADD_OP          shift and go to state 22
    MUL_OP          shift and go to state 21


state 52

    (9) assignation-serie -> IDENTIFIER = FOREACH ( def-iter ) { . programme }
    (1) programme -> . statement ;
    (2) programme -> . statement ; programme
    (3) statement -> . assignation-valeur
    (4) statement -> . assignation-serie
    (5) statement -> . structure
    (6) statement -> . PRINT expression
    (7) assignation-valeur -> . IDENTIFIER = expression
    (8) assignation-serie -> . IDENTIFIER = def-iter : expression
    (9) assignation-serie -> . IDENTIFIER = FOREACH ( def-iter ) { programme }
    (12) structure -> . WHILE expression { programme }
    (13) structure -> . IF expression { programme }
    (14) structure -> . IF expression { programme } ELSE { programme }

    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 8
    WHILE           shift and go to state 1
    IF              shift and go to state 7

    structure                      shift and go to state 2
    assignation-valeur             shift and go to state 3
    programme                      shift and go to state 54
    assignation-serie              shift and go to state 5
    statement                      shift and go to state 9

state 53

    (14) structure -> IF expression { programme } ELSE { programme . }

    }               shift and go to state 55


state 54

    (9) assignation-serie -> IDENTIFIER = FOREACH ( def-iter ) { programme . }

    }               shift and go to state 56


state 55

    (14) structure -> IF expression { programme } ELSE { programme } .

    ;               reduce using rule 14 (structure -> IF expression { programme } ELSE { programme } .)


state 56

    (9) assignation-serie -> IDENTIFIER = FOREACH ( def-iter ) { programme } .

    ;               reduce using rule 9 (assignation-serie -> IDENTIFIER = FOREACH ( def-iter ) { programme } .)

