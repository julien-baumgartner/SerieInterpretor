Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement ;
Rule 2     programme -> statement ; programme
Rule 3     statement -> assignation-valeur
Rule 4     statement -> assignation-serie
Rule 5     statement -> structure
Rule 6     statement -> PRINT expression
Rule 7     assignation-valeur -> IDENTIFIER = expression
Rule 8     assignation-serie -> IDENTIFIER = def-iter : expression
Rule 9     assignation-serie -> IDENTIFIER = FOREACH ( def-iter ) { programme }
Rule 10    def-iter -> IDENTIFIER ITER IDENTIFIER
Rule 11    def-iter -> IDENTIFIER ITER IDENTIFIER AS expression
Rule 12    structure -> WHILE expression { programme }
Rule 13    structure -> IF expression { programme }
Rule 14    structure -> IF expression { programme } ELSE { programme }
Rule 15    expression -> expression ADD_OP expression
Rule 16    expression -> expression MUL_OP expression
Rule 17    expression -> ADD_OP expression
Rule 18    expression -> ( expression )
Rule 19    expression -> NUMBER
Rule 20    expression -> IDENTIFIER
Rule 21    expression -> IDENTIFIER [ expression ]

Terminals, with rules where they appear

(                    : 9 18
)                    : 9 18
:                    : 8
;                    : 1 2
=                    : 7 8 9
ADD_OP               : 15 17
AS                   : 11
ELSE                 : 14
FOREACH              : 9
IDENTIFIER           : 7 8 9 10 10 11 11 20 21
IF                   : 13 14
ITER                 : 10 11
MUL_OP               : 16
NUMBER               : 19
PRINT                : 6
WHILE                : 12
[                    : 21
]                    : 21
error                : 
{                    : 9 12 13 14 14
}                    : 9 12 13 14 14

Nonterminals, with rules where they appear

assignation-serie    : 4
assignation-valeur   : 3
def-iter             : 8 9
expression           : 6 7 8 11 12 13 14 15 15 16 16 17 18 21
programme            : 2 9 12 13 14 14 0
statement            : 1 2
structure            : 5

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement ;
    (2) programme -> . statement ; programme
    (3) statement -> . assignation-valeur
    (4) statement -> . assignation-serie
    (5) statement -> . structure
    (6) statement -> . PRINT expression
    (7) assignation-valeur -> . IDENTIFIER = expression
    (8) assignation-serie -> . IDENTIFIER = def-iter : expression
    (9) assignation-serie -> . IDENTIFIER = FOREACH ( def-iter ) { programme }
    (12) structure -> . WHILE expression { programme }
    (13) structure -> . IF expression { programme }
    (14) structure -> . IF expression { programme } ELSE { programme }

    PRINT           shift and go to state 9
    IDENTIFIER      shift and go to state 1
    WHILE           shift and go to state 2
    IF              shift and go to state 8

    programme                      shift and go to state 7
    assignation-serie              shift and go to state 3
    structure                      shift and go to state 4
    statement                      shift and go to state 6
    assignation-valeur             shift and go to state 5

state 1

    (7) assignation-valeur -> IDENTIFIER . = expression
    (8) assignation-serie -> IDENTIFIER . = def-iter : expression
    (9) assignation-serie -> IDENTIFIER . = FOREACH ( def-iter ) { programme }

    =               shift and go to state 10


state 2

    (12) structure -> WHILE . expression { programme }
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 14
    (               shift and go to state 15
    NUMBER          shift and go to state 13
    IDENTIFIER      shift and go to state 11

    expression                     shift and go to state 12

state 3

    (4) statement -> assignation-serie .

    ;               reduce using rule 4 (statement -> assignation-serie .)


state 4

    (5) statement -> structure .

    ;               reduce using rule 5 (statement -> structure .)


state 5

    (3) statement -> assignation-valeur .

    ;               reduce using rule 3 (statement -> assignation-valeur .)


state 6

    (1) programme -> statement . ;
    (2) programme -> statement . ; programme

    ;               shift and go to state 16


state 7

    (0) S' -> programme .



state 8

    (13) structure -> IF . expression { programme }
    (14) structure -> IF . expression { programme } ELSE { programme }
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 14
    (               shift and go to state 15
    NUMBER          shift and go to state 13
    IDENTIFIER      shift and go to state 11

    expression                     shift and go to state 17

state 9

    (6) statement -> PRINT . expression
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 14
    (               shift and go to state 15
    NUMBER          shift and go to state 13
    IDENTIFIER      shift and go to state 11

    expression                     shift and go to state 18

state 10

    (7) assignation-valeur -> IDENTIFIER = . expression
    (8) assignation-serie -> IDENTIFIER = . def-iter : expression
    (9) assignation-serie -> IDENTIFIER = . FOREACH ( def-iter ) { programme }
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]
    (10) def-iter -> . IDENTIFIER ITER IDENTIFIER
    (11) def-iter -> . IDENTIFIER ITER IDENTIFIER AS expression

    FOREACH         shift and go to state 21
    ADD_OP          shift and go to state 14
    (               shift and go to state 15
    NUMBER          shift and go to state 13
    IDENTIFIER      shift and go to state 19

    def-iter                       shift and go to state 20
    expression                     shift and go to state 22

state 11

    (20) expression -> IDENTIFIER .
    (21) expression -> IDENTIFIER . [ expression ]

    ADD_OP          reduce using rule 20 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 20 (expression -> IDENTIFIER .)
    {               reduce using rule 20 (expression -> IDENTIFIER .)
    ;               reduce using rule 20 (expression -> IDENTIFIER .)
    )               reduce using rule 20 (expression -> IDENTIFIER .)
    ]               reduce using rule 20 (expression -> IDENTIFIER .)
    :               reduce using rule 20 (expression -> IDENTIFIER .)
    [               shift and go to state 23


state 12

    (12) structure -> WHILE expression . { programme }
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    {               shift and go to state 25
    ADD_OP          shift and go to state 26
    MUL_OP          shift and go to state 24


state 13

    (19) expression -> NUMBER .

    ADD_OP          reduce using rule 19 (expression -> NUMBER .)
    MUL_OP          reduce using rule 19 (expression -> NUMBER .)
    {               reduce using rule 19 (expression -> NUMBER .)
    ;               reduce using rule 19 (expression -> NUMBER .)
    )               reduce using rule 19 (expression -> NUMBER .)
    ]               reduce using rule 19 (expression -> NUMBER .)
    :               reduce using rule 19 (expression -> NUMBER .)


state 14

    (17) expression -> ADD_OP . expression
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 14
    (               shift and go to state 15
    NUMBER          shift and go to state 13
    IDENTIFIER      shift and go to state 11

    expression                     shift and go to state 27

state 15

    (18) expression -> ( . expression )
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 14
    (               shift and go to state 15
    NUMBER          shift and go to state 13
    IDENTIFIER      shift and go to state 11

    expression                     shift and go to state 28

state 16

    (1) programme -> statement ; .
    (2) programme -> statement ; . programme
    (1) programme -> . statement ;
    (2) programme -> . statement ; programme
    (3) statement -> . assignation-valeur
    (4) statement -> . assignation-serie
    (5) statement -> . structure
    (6) statement -> . PRINT expression
    (7) assignation-valeur -> . IDENTIFIER = expression
    (8) assignation-serie -> . IDENTIFIER = def-iter : expression
    (9) assignation-serie -> . IDENTIFIER = FOREACH ( def-iter ) { programme }
    (12) structure -> . WHILE expression { programme }
    (13) structure -> . IF expression { programme }
    (14) structure -> . IF expression { programme } ELSE { programme }

    }               reduce using rule 1 (programme -> statement ; .)
    $end            reduce using rule 1 (programme -> statement ; .)
    PRINT           shift and go to state 9
    IDENTIFIER      shift and go to state 1
    WHILE           shift and go to state 2
    IF              shift and go to state 8

    programme                      shift and go to state 29
    assignation-serie              shift and go to state 3
    structure                      shift and go to state 4
    statement                      shift and go to state 6
    assignation-valeur             shift and go to state 5

state 17

    (13) structure -> IF expression . { programme }
    (14) structure -> IF expression . { programme } ELSE { programme }
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    {               shift and go to state 30
    ADD_OP          shift and go to state 26
    MUL_OP          shift and go to state 24


state 18

    (6) statement -> PRINT expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ;               reduce using rule 6 (statement -> PRINT expression .)
    ADD_OP          shift and go to state 26
    MUL_OP          shift and go to state 24


state 19

    (20) expression -> IDENTIFIER .
    (21) expression -> IDENTIFIER . [ expression ]
    (10) def-iter -> IDENTIFIER . ITER IDENTIFIER
    (11) def-iter -> IDENTIFIER . ITER IDENTIFIER AS expression

    ADD_OP          reduce using rule 20 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 20 (expression -> IDENTIFIER .)
    ;               reduce using rule 20 (expression -> IDENTIFIER .)
    [               shift and go to state 23
    ITER            shift and go to state 31


state 20

    (8) assignation-serie -> IDENTIFIER = def-iter . : expression

    :               shift and go to state 32


state 21

    (9) assignation-serie -> IDENTIFIER = FOREACH . ( def-iter ) { programme }

    (               shift and go to state 33


state 22

    (7) assignation-valeur -> IDENTIFIER = expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ;               reduce using rule 7 (assignation-valeur -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 26
    MUL_OP          shift and go to state 24


state 23

    (21) expression -> IDENTIFIER [ . expression ]
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 14
    (               shift and go to state 15
    NUMBER          shift and go to state 13
    IDENTIFIER      shift and go to state 11

    expression                     shift and go to state 34

state 24

    (16) expression -> expression MUL_OP . expression
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 14
    (               shift and go to state 15
    NUMBER          shift and go to state 13
    IDENTIFIER      shift and go to state 11

    expression                     shift and go to state 35

state 25

    (12) structure -> WHILE expression { . programme }
    (1) programme -> . statement ;
    (2) programme -> . statement ; programme
    (3) statement -> . assignation-valeur
    (4) statement -> . assignation-serie
    (5) statement -> . structure
    (6) statement -> . PRINT expression
    (7) assignation-valeur -> . IDENTIFIER = expression
    (8) assignation-serie -> . IDENTIFIER = def-iter : expression
    (9) assignation-serie -> . IDENTIFIER = FOREACH ( def-iter ) { programme }
    (12) structure -> . WHILE expression { programme }
    (13) structure -> . IF expression { programme }
    (14) structure -> . IF expression { programme } ELSE { programme }

    PRINT           shift and go to state 9
    IDENTIFIER      shift and go to state 1
    WHILE           shift and go to state 2
    IF              shift and go to state 8

    programme                      shift and go to state 36
    assignation-serie              shift and go to state 3
    structure                      shift and go to state 4
    statement                      shift and go to state 6
    assignation-valeur             shift and go to state 5

state 26

    (15) expression -> expression ADD_OP . expression
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 14
    (               shift and go to state 15
    NUMBER          shift and go to state 13
    IDENTIFIER      shift and go to state 11

    expression                     shift and go to state 37

state 27

    (17) expression -> ADD_OP expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 17 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 17 (expression -> ADD_OP expression .)
    {               reduce using rule 17 (expression -> ADD_OP expression .)
    ;               reduce using rule 17 (expression -> ADD_OP expression .)
    )               reduce using rule 17 (expression -> ADD_OP expression .)
    ]               reduce using rule 17 (expression -> ADD_OP expression .)
    :               reduce using rule 17 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 26 ]
  ! MUL_OP          [ shift and go to state 24 ]


state 28

    (18) expression -> ( expression . )
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    )               shift and go to state 38
    ADD_OP          shift and go to state 26
    MUL_OP          shift and go to state 24


state 29

    (2) programme -> statement ; programme .

    }               reduce using rule 2 (programme -> statement ; programme .)
    $end            reduce using rule 2 (programme -> statement ; programme .)


state 30

    (13) structure -> IF expression { . programme }
    (14) structure -> IF expression { . programme } ELSE { programme }
    (1) programme -> . statement ;
    (2) programme -> . statement ; programme
    (3) statement -> . assignation-valeur
    (4) statement -> . assignation-serie
    (5) statement -> . structure
    (6) statement -> . PRINT expression
    (7) assignation-valeur -> . IDENTIFIER = expression
    (8) assignation-serie -> . IDENTIFIER = def-iter : expression
    (9) assignation-serie -> . IDENTIFIER = FOREACH ( def-iter ) { programme }
    (12) structure -> . WHILE expression { programme }
    (13) structure -> . IF expression { programme }
    (14) structure -> . IF expression { programme } ELSE { programme }

    PRINT           shift and go to state 9
    IDENTIFIER      shift and go to state 1
    WHILE           shift and go to state 2
    IF              shift and go to state 8

    programme                      shift and go to state 39
    assignation-serie              shift and go to state 3
    structure                      shift and go to state 4
    statement                      shift and go to state 6
    assignation-valeur             shift and go to state 5

state 31

    (10) def-iter -> IDENTIFIER ITER . IDENTIFIER
    (11) def-iter -> IDENTIFIER ITER . IDENTIFIER AS expression

    IDENTIFIER      shift and go to state 40


state 32

    (8) assignation-serie -> IDENTIFIER = def-iter : . expression
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 14
    (               shift and go to state 15
    NUMBER          shift and go to state 13
    IDENTIFIER      shift and go to state 11

    expression                     shift and go to state 41

state 33

    (9) assignation-serie -> IDENTIFIER = FOREACH ( . def-iter ) { programme }
    (10) def-iter -> . IDENTIFIER ITER IDENTIFIER
    (11) def-iter -> . IDENTIFIER ITER IDENTIFIER AS expression

    IDENTIFIER      shift and go to state 42

    def-iter                       shift and go to state 43

state 34

    (21) expression -> IDENTIFIER [ expression . ]
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ]               shift and go to state 44
    ADD_OP          shift and go to state 26
    MUL_OP          shift and go to state 24


state 35

    (16) expression -> expression MUL_OP expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 16 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 16 (expression -> expression MUL_OP expression .)
    {               reduce using rule 16 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 16 (expression -> expression MUL_OP expression .)
    )               reduce using rule 16 (expression -> expression MUL_OP expression .)
    ]               reduce using rule 16 (expression -> expression MUL_OP expression .)
    :               reduce using rule 16 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 26 ]
  ! MUL_OP          [ shift and go to state 24 ]


state 36

    (12) structure -> WHILE expression { programme . }

    }               shift and go to state 45


state 37

    (15) expression -> expression ADD_OP expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 15 (expression -> expression ADD_OP expression .)
    {               reduce using rule 15 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 15 (expression -> expression ADD_OP expression .)
    )               reduce using rule 15 (expression -> expression ADD_OP expression .)
    ]               reduce using rule 15 (expression -> expression ADD_OP expression .)
    :               reduce using rule 15 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 24

  ! MUL_OP          [ reduce using rule 15 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 26 ]


state 38

    (18) expression -> ( expression ) .

    ADD_OP          reduce using rule 18 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 18 (expression -> ( expression ) .)
    {               reduce using rule 18 (expression -> ( expression ) .)
    ;               reduce using rule 18 (expression -> ( expression ) .)
    )               reduce using rule 18 (expression -> ( expression ) .)
    ]               reduce using rule 18 (expression -> ( expression ) .)
    :               reduce using rule 18 (expression -> ( expression ) .)


state 39

    (13) structure -> IF expression { programme . }
    (14) structure -> IF expression { programme . } ELSE { programme }

    }               shift and go to state 46


state 40

    (10) def-iter -> IDENTIFIER ITER IDENTIFIER .
    (11) def-iter -> IDENTIFIER ITER IDENTIFIER . AS expression

    )               reduce using rule 10 (def-iter -> IDENTIFIER ITER IDENTIFIER .)
    :               reduce using rule 10 (def-iter -> IDENTIFIER ITER IDENTIFIER .)
    AS              shift and go to state 47


state 41

    (8) assignation-serie -> IDENTIFIER = def-iter : expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    ;               reduce using rule 8 (assignation-serie -> IDENTIFIER = def-iter : expression .)
    ADD_OP          shift and go to state 26
    MUL_OP          shift and go to state 24


state 42

    (10) def-iter -> IDENTIFIER . ITER IDENTIFIER
    (11) def-iter -> IDENTIFIER . ITER IDENTIFIER AS expression

    ITER            shift and go to state 31


state 43

    (9) assignation-serie -> IDENTIFIER = FOREACH ( def-iter . ) { programme }

    )               shift and go to state 48


state 44

    (21) expression -> IDENTIFIER [ expression ] .

    ADD_OP          reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)
    MUL_OP          reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)
    {               reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)
    ;               reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)
    )               reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)
    ]               reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)
    :               reduce using rule 21 (expression -> IDENTIFIER [ expression ] .)


state 45

    (12) structure -> WHILE expression { programme } .

    ;               reduce using rule 12 (structure -> WHILE expression { programme } .)


state 46

    (13) structure -> IF expression { programme } .
    (14) structure -> IF expression { programme } . ELSE { programme }

    ;               reduce using rule 13 (structure -> IF expression { programme } .)
    ELSE            shift and go to state 49


state 47

    (11) def-iter -> IDENTIFIER ITER IDENTIFIER AS . expression
    (15) expression -> . expression ADD_OP expression
    (16) expression -> . expression MUL_OP expression
    (17) expression -> . ADD_OP expression
    (18) expression -> . ( expression )
    (19) expression -> . NUMBER
    (20) expression -> . IDENTIFIER
    (21) expression -> . IDENTIFIER [ expression ]

    ADD_OP          shift and go to state 14
    (               shift and go to state 15
    NUMBER          shift and go to state 13
    IDENTIFIER      shift and go to state 11

    expression                     shift and go to state 50

state 48

    (9) assignation-serie -> IDENTIFIER = FOREACH ( def-iter ) . { programme }

    {               shift and go to state 51


state 49

    (14) structure -> IF expression { programme } ELSE . { programme }

    {               shift and go to state 52


state 50

    (11) def-iter -> IDENTIFIER ITER IDENTIFIER AS expression .
    (15) expression -> expression . ADD_OP expression
    (16) expression -> expression . MUL_OP expression

    )               reduce using rule 11 (def-iter -> IDENTIFIER ITER IDENTIFIER AS expression .)
    :               reduce using rule 11 (def-iter -> IDENTIFIER ITER IDENTIFIER AS expression .)
    ADD_OP          shift and go to state 26
    MUL_OP          shift and go to state 24


state 51

    (9) assignation-serie -> IDENTIFIER = FOREACH ( def-iter ) { . programme }
    (1) programme -> . statement ;
    (2) programme -> . statement ; programme
    (3) statement -> . assignation-valeur
    (4) statement -> . assignation-serie
    (5) statement -> . structure
    (6) statement -> . PRINT expression
    (7) assignation-valeur -> . IDENTIFIER = expression
    (8) assignation-serie -> . IDENTIFIER = def-iter : expression
    (9) assignation-serie -> . IDENTIFIER = FOREACH ( def-iter ) { programme }
    (12) structure -> . WHILE expression { programme }
    (13) structure -> . IF expression { programme }
    (14) structure -> . IF expression { programme } ELSE { programme }

    PRINT           shift and go to state 9
    IDENTIFIER      shift and go to state 1
    WHILE           shift and go to state 2
    IF              shift and go to state 8

    programme                      shift and go to state 53
    assignation-serie              shift and go to state 3
    structure                      shift and go to state 4
    statement                      shift and go to state 6
    assignation-valeur             shift and go to state 5

state 52

    (14) structure -> IF expression { programme } ELSE { . programme }
    (1) programme -> . statement ;
    (2) programme -> . statement ; programme
    (3) statement -> . assignation-valeur
    (4) statement -> . assignation-serie
    (5) statement -> . structure
    (6) statement -> . PRINT expression
    (7) assignation-valeur -> . IDENTIFIER = expression
    (8) assignation-serie -> . IDENTIFIER = def-iter : expression
    (9) assignation-serie -> . IDENTIFIER = FOREACH ( def-iter ) { programme }
    (12) structure -> . WHILE expression { programme }
    (13) structure -> . IF expression { programme }
    (14) structure -> . IF expression { programme } ELSE { programme }

    PRINT           shift and go to state 9
    IDENTIFIER      shift and go to state 1
    WHILE           shift and go to state 2
    IF              shift and go to state 8

    programme                      shift and go to state 54
    assignation-serie              shift and go to state 3
    structure                      shift and go to state 4
    statement                      shift and go to state 6
    assignation-valeur             shift and go to state 5

state 53

    (9) assignation-serie -> IDENTIFIER = FOREACH ( def-iter ) { programme . }

    }               shift and go to state 55


state 54

    (14) structure -> IF expression { programme } ELSE { programme . }

    }               shift and go to state 56


state 55

    (9) assignation-serie -> IDENTIFIER = FOREACH ( def-iter ) { programme } .

    ;               reduce using rule 9 (assignation-serie -> IDENTIFIER = FOREACH ( def-iter ) { programme } .)


state 56

    (14) structure -> IF expression { programme } ELSE { programme } .

    ;               reduce using rule 14 (structure -> IF expression { programme } ELSE { programme } .)

