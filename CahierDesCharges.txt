 --- Cahier des charges - List Interpretor
 --- Joel Vaucher et Julien Baumgartner
 --- 06.12.2016 cours Compilateur
-----------------------------------------------
  -- Introduction
-----------------------------------------------
Ce projet est un language permettant d'exprimer des séries mathématiques.

Le language permet également de faire des opérations de base, ainsi que
de afficher des valeurs numériques.

ATTENTION: contrairement à des objets/listes où les valeurs sont calculées à l'avance,
les séries ne calculent leurs valeurs uniquement lorsqu'on souhaite utiliser une valeur de la série.
Ceci est dû au fait qu'une série est par définition infinie, ce qui rend illusoire le précalcul.

La suite de Topic qui va suivre montre des exemples pouvant être utilisés tel quel.
-----------------------------------------------
 -- définition d'une liste
-----------------------------------------------
c1 = x iter y as 0: y+1;

c1 est le nom de la variable contenant la liste.
x est le nom de l'index des éléments de la série pouvant être utilisé dans le calcul de la série
y est le nom de la valeur de l'élément précédent de la série pouvant être utilisé dans le calcul de la série
0 est la valeur de l'élement à l'indice -1
y+1 est la fonction qui va être appelée pour trouver l'élement suivant à partir de l'index et de la valeur de l'élement actuel

la liste stocke { variable, valeur_de_départ, nom_iter_local, nom_var_local, function }
ici {c1, 10, "x", "y", "y+1"}
Si la liste répresente {1, 2, 3, 4, 5, ...), son contenu n'est pas encore calculé.
Il ne le sera uniquement lorsqu'on cherchera à obtenir une valeur de la série.

Le contenu est calculé de la manière suivante
{
  c1[0]: valeur_de_départ+1,  //1
  c1[1]: c1[0]+1,             //2
  c1[2]: c1[1]+1,             //3
  ...
}
ainsi avec une fonction plus compliqué "x + y*2 - 5"
c2 = x iter y as 0 : x + y*2 - 5;
{
  c2[0]: 0 + valeur_de_départ*2 - 5,   //-5
  c2[1]: 1 + c2[0]*2 - 5,              //-14
  c2[2]: 2 + c2[1]*2 - 5,              //-31
  ...
}

 -- utilisation de variable global
-----------------------------------------------
Il est possible d'utiliser des variables d'une portée supérieure.
A l'extérieur de la fonction "c1[x] * c2[x] + y", les valeurs de 
x et y n'existe pas 

c3 = x iter y as 0 : c1[x] * c2[x] + y;

ici {c3, 0, c1[localIt]*c2[localIt]+localVar}
cette liste est { 10, 17.5, 22.5, ... 

 -- récupérer le nième élement d'une liste
-----------------------------------------------
c3[2]

ici {c3, 0, c1[localIt]*c2[localIt] + LocalVal}
donc
pour calculer c3[2], il faut c3[1] donc il faut c3[0]

c3[0] = c1[0]*c2[0] + 0 = 2*5+0 = 10
c3[1] = c1[1]*c2[1] + c3[0] = 3*2.5+10 = 17.5
c3[2] = c1[2]*c[2] + c3[1] = 4*1.25+17.5 = 22.5

cela correspond à la valeur 22.5

 -- affichage d'une valeur
-----------------------------------------------
print("text");
print(c1, 0, 4);
print(c2[2]);
print(c3, 1, 2);

affiche

text
{2,3,4,5}
1.25
{17.5,22.5}

 -- boucle foreach
-----------------------------------------------
Remarque foreach est une fonction !!!
y est la valeur précedente dans c4

c4 = x iter y as 2 : -y;  //{-2, 2, -2, 2, -2, 2}
c5 = foreach( x iter y as 0) {
	if(y1 < 5) {
		y = c4[c1[x]] + y2;
	} else {
		y = c4[c1[x]] * y2;
	}
}

on utilise x pour parcourir c1 { 2, 3, 4, 5, 6 ... }
on utilise ces valeurs pour parcourir c4
        0   1 x|2   3   4   5   6
c4 = { -2,  2, -2,  2, -2,  2, -2,  2, ...}

                  y1    y2
c5[0] = return c4[2] +  0 = -2 +  0 = -2
c5[1] = return c4[3] + -2 =  2 + -2 = 0
c5[2] = return c4[4] +  0 = -2 +  0 = -2
c5[3] = return c4[5] * -2 =  2 * -2 = -4
c5[4] = return c4[6] * -4 = -2 * -4 = 8
...



